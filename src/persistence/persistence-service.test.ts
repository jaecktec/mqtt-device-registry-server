import * as debugFn from 'debug';import * as Loki from 'lokijs';import { assert } from 'chai';import { mock, instance, when, verify, capture, anything } from 'ts-mockito';import { PersistenceService } from './persistence-service';import { DatabaseTables } from './database';import { DeviceConnection } from '../mqtt/device-connection/device-connection';import { Device } from './device';import resetAllMocks = jest.resetAllMocks;import { Value } from './value';const debug = debugFn('app.test.persistence-service.ts');describe('PersistenceServiceTest', () => {    let unit: PersistenceService;    let databaseTables: DatabaseTables;    beforeEach(() => {        databaseTables = {            Value: undefined,            Device: undefined,            Database: undefined        };        unit = new PersistenceService(databaseTables);        resetAllMocks();    });    it('handleNewDevices - when connection is added and device is not known, store new Device', () => {        const deviceConnection = mock(DeviceConnection);        when(deviceConnection.getDeviceId()).thenReturn('deviceId');        when(deviceConnection.getNodeId()).thenReturn('nodeId');        const deviceDb: Loki.Collection<Device> = mock(Loki.Collection);        when(deviceDb.findOne()).thenReturn(undefined);        databaseTables.Device = instance(deviceDb);        unit.handleNewDevices([instance(deviceConnection)]);        // then expect        verify(deviceDb.findOne()).called();        const [query] = capture(deviceDb.findOne).last();        assert.equal(query['nodeId'], 'nodeId');        assert.equal(query['id'], 'deviceId');        verify(deviceDb.update()).never();        verify(deviceDb.insert()).called();        const [insertResult] = capture(deviceDb.insert).last();        assert.equal(insertResult['nodeId'], 'nodeId');        assert.equal(insertResult['id'], 'deviceId');    });    it('handleNewDevices - when connection is added and device is known, update new Device', () => {        const deviceConnection = mock(DeviceConnection);        when(deviceConnection.getDeviceId()).thenReturn('deviceId');        when(deviceConnection.getNodeId()).thenReturn('nodeId');        const mockedDeviceEntry: Device = {            nodeId: 'nodeId',            id: 'deviceId',            created: new Date(),            connected: new Date(),            disconnected: new Date()        };        const deviceDb: Loki.Collection<Device> = mock(Loki.Collection);        when(deviceDb.findOne(anything())).thenReturn(mockedDeviceEntry);        databaseTables.Device = instance(deviceDb);        unit.handleNewDevices([instance(deviceConnection)]);        // then expect        verify(deviceDb.findOne()).called();        const [query] = capture(deviceDb.findOne).last();        assert.equal(query['nodeId'], 'nodeId');        assert.equal(query['id'], 'deviceId');        verify(deviceDb.insert()).never();        verify(deviceDb.update()).called();        const [updateResult] = capture(deviceDb.update).last();        assert.equal(updateResult['nodeId'], 'nodeId');        assert.equal(updateResult['id'], 'deviceId');        assert(updateResult['connected'].getTime() >= mockedDeviceEntry.connected.getTime());        assert.isUndefined(updateResult['disconnected']);    });    it('handleNodeDisconnect - when connection is terminated save timestamp in db', () => {        const deviceConnection = mock(DeviceConnection);        when(deviceConnection.getDeviceId()).thenReturn('deviceId');        when(deviceConnection.getNodeId()).thenReturn('nodeId');        const mockedDeviceEntry: Device = {            nodeId: 'nodeId',            id: 'deviceId',            created: new Date(0),            connected: new Date(0),            disconnected: undefined        };        const deviceDb: Loki.Collection<Device> = mock(Loki.Collection);        when(deviceDb.findOne(anything())).thenReturn(mockedDeviceEntry);        databaseTables.Device = instance(deviceDb);        unit.handleNodeDisconnect([instance(deviceConnection)]);        // then expect        verify(deviceDb.findOne()).called();        const [query] = capture(deviceDb.findOne).last();        assert.equal(query['nodeId'], 'nodeId');        assert.equal(query['id'], 'deviceId');        verify(deviceDb.update()).called();        const [updateResult] = capture(deviceDb.update).last();        assert.equal(updateResult['nodeId'], 'nodeId');        assert.equal(updateResult['id'], 'deviceId');        assert(updateResult['connected'].getTime() > mockedDeviceEntry.connected.getTime());        assert.isDefined(updateResult['disconnected']);    });    it('handleDeviceValue - when value is reported save value and add timestamp', () => {        const deviceConnection = mock(DeviceConnection);        when(deviceConnection.getDeviceId()).thenReturn('deviceId');        when(deviceConnection.getNodeId()).thenReturn('nodeId');        when(deviceConnection.getNumMessages())            .thenReturn(1)            .thenReturn(0);        const valueMessage = {some: 'value'};        when(deviceConnection.getMessage())            .thenReturn(valueMessage);        const valueDb: Loki.Collection<Value> = mock(Loki.Collection);        databaseTables.Value = instance(valueDb);        unit.handleDeviceValue([instance(deviceConnection)]);        verify(valueDb.insert()).called();        const [insert] = capture(valueDb.insert).last();        assert.equal(insert['nodeId'], 'nodeId');        assert.equal(insert['deviceId'], 'deviceId');        assert.isDefined(insert['timestamp']);        assert.equal(insert['data'].some, 'value');    });});